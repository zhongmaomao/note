# 硬件
1. 寄存器(32位、64位)、CPU Cache(L123)、内存、SSD/HDD硬盘
2. 提高CPU速度：提高数据缓存命中率、提高指令缓存命中率(分支预测)、多核CPU绑定线程
3. CPU缓存一致性：写直达、写回；总线嗅探、MESI
4. CPU线程(task_struct)调度：实时任务(Deadline, FIFO, RR)、普通任务(CFS)
5. 中断：上半部(硬中断：暂时关闭中断请求，处理硬件或时间敏感任务)、下半部(软中断：内核线程)
6. Linux：Multiply多任务、SMP对称多处理、ELF可执行文件链接格式、Monolithic Kernel宏内核

# 内存管理

## 虚拟内存
作用：
1. 虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
2. 由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
3. 页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。
### 分段
1. 段选择因子(查段表 -> 段基地址) + 段内偏移量
2. 问题 ： 内存碎片、内存交换(swap)效率低

### 分页
1. 虚拟页号(查页表 -> 物理页号) + 页内偏移
2. 二级页表(32 - 10, 10, 12), 四级页表(64)
3. TLB: 快表、页表缓存、转址旁路缓存

### 段页式
1. 段号(查段表 -> 页表地址) + 段内页号(查段页表 -> 物理页号) + 页内位移

## Linux内存分布
X86架构CPU：逻辑地址　--(段式内存管理单元)-->  线性地址/虚拟地址  --(页式内存管理单元)-->  物理地址  
Linux通过把所有逻辑地址对应段基地址设为0，忽略逻辑地址，段只被用于访问控制和内存保护

![32位虚拟内存布局](https://raw.githubusercontent.com/zhongmaomao/img/master//md/pictures/32位虚拟内存布局.webp)

- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
- 文件映射与匿名映射段，包括动态库、共享内存、mmap分配内存等；
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；

## malloc
malloc(), realloc(), calloc(), alloca()
brk(), mmap()  
malloc()申请的是虚拟内存，只有访问时才分配物理内存  
free()会向左偏移16字节分析内存块大小和信息
- brk()从堆空间直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中
  - 防止每次分配空间都需要内核态，如果内存池得虚拟地址对应物理地址映射还在，也不会缺页中断
  - 但是会产生小的内存碎片，形成内存泄漏(且无法通过valgrind检测)
- mmap()从文件映射空间通过隐式映射分配，当内存释放的时候归还给操作系统
  - 每次都会发生运行态切换
  - 每次分配的都是新的虚拟内存，所以首次访问会发生缺页中断

## 内存满了
后台内存回收(异步)、直接内存回收(同步)、OOM  
文件页(kswapd:干净页、脏页)、匿名页(swap)  
SMP架构、NUMA架构

## LRU
Linux、MySQL：预读失效 + 缓存污染

# 进程管理
![10-进程七中状态](https://raw.githubusercontent.com/zhongmaomao/img/master//md/pictures/10-进程七中状态.webp)

PCB：进程描述信息(PID, UID), 进程控制管理信息(状态、优先级), 资源分配清单(内存、IO), CPU相关(寄存器)

## 进程、线程  
资源分配单位、cpu运行调度单位  
用户线程、内核线程、轻量级进程  
一对一、多对一、多对多、混合模式

## 调度

FIFO、SJF  
高响应比优先 ： (等待时间+服务时间) / 服务时间  
RR时间片轮转  
HPF最高优先级
MFQ多级反馈队列  

## 进程间通信
管道、消息队列、共享内存、信号量(PV:互斥、同步)、信号(kill, 唯一的异步通信机制)、Socket

## 同步、互斥
1. 锁 -> 互斥  
   TestAndSet指令
2. pv -> 互斥, 异步

- 哲学家用餐：
  - 叉子数组普通pv，死锁
  - 用餐状态pv，同时只能一人(所有叉子作为一个整体资源)
  - 分奇偶对叉子数组pv(资源有序分配法破坏环路等待)
  - 哲学家状态数组pv(缩小粒度，只有在拿叉子时独占所有叉子)
- 读者、写者
  - 读者优先、写者优先
  - 公平竞争(当有写者在阻塞队列时阻塞所有人)

## 死锁
互斥、持有并等待、不可剥夺、环路等待(有序分配法破坏)

## 锁
互斥锁、自旋锁、读写锁(同上3种优先级)、悲观锁、乐观锁

# 调度

- 进程调度
  - FCFS、SJF -> 高响应比
  - RR、HPF最高优先级 -> MFQ多级反馈队列
- 内存调度
  - OPT最佳页面置换算法
  - FIFO、LRU -> 时钟页面置换算法
  - LFU
- 磁盘调度(寻道)
  - FCFS
  - 最短寻道时间SSF(局部扫描，饥饿)
  - 扫描算法(中间的更快) -> 循环扫描 -> LOOK, C-LOOK




# 文件
打开文件表、文件描述符
## 文件存储
- 连续空间存放
  - 一次寻道、空间碎片、不易扩展
- 非连续空间存放
  - 链表
    - 隐式链表(一个指针坏了，后续数据都失效)
    - 显式链接(内存)
  - 索引
    - 链式索引块
    - 多级索引块
unix：文件头包含13个指针
## 空闲空间管理
空闲表法、空闲链表法、位图法(Linux)
## 链接
- 硬链接(共享inode，所以无法跨越文件系统)
- 软链接(独立的inode，但是inode指向同一个文件路径，可以跨越文件系统)
## 文件I/O
- 缓冲与非缓冲I/O(指标准库缓存，如cout与endl)
  - 用户 <-> 标准库缓存 <-> 系统I/O
- 直接与非直接I/O(指操作系统缓存)
  - 用户 <-> 内核缓存 <-> 磁盘读写
- 阻塞与非阻塞 I/O VS 同步与异步 I/O
  - I/O分步：
    - 数据准备的过程
    - 数据从内核空间拷贝到用户进程缓冲区的过程
  - 阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。
  - 异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。

# 设备管理
DMA(Direct Memory Access)、设备控制器、设备驱动程序

# 网络系统
传统I/O做法：  
磁盘 --DMA--> 内核缓冲区 --CPU--> 用户缓冲区 --CPU--> 内核socket缓冲区 --DMA--> 网卡  
4次用户态和内核态上下文切换，4次数据拷贝

sendfile + SG-DMA(scatter gather)

- 传输大文件的时候，使用「异步 I/O + 直接 I/O」；
- 传输小文件的时候，则使用「零拷贝技术」；
